---
import Layout from '@/layouts/Layout.astro';
import { ColorConverter } from '@/components/converters/ColorConverter.tsx';
import {
  buildDefaultContent,
  colorFormatMeta,
  colorIntentModifiers,
  getDefaultColor,
  getExampleConversion,
  isModifierApplicable,
} from '@/pages/convert/color/page-data';
import type {
  ColorFormatMeta,
  ColorIntentModifier,
  SupportedFormat,
} from '@/data/colorModifiers';
import type { ComponentProps } from 'react';

type ColorConverterProps = ComponentProps<typeof ColorConverter>;
type ResolvedHeaderOverrides = NonNullable<ColorConverterProps['headerOverrides']>;
type HeaderFeatureArray = NonNullable<ResolvedHeaderOverrides['features']>;
type HeaderFeature = HeaderFeatureArray[number];
type HeaderBadge = NonNullable<ResolvedHeaderOverrides['badge']>;
type TargetFormat = ColorConverterProps['targetFormat'];

interface Props {
  fromFormat: ColorFormatMeta;
  toFormat: ColorFormatMeta;
  fromKey: SupportedFormat;
  toKey: SupportedFormat;
  modifier?: ColorIntentModifier;
}

const { fromFormat, toFormat, fromKey, toKey, modifier } = Astro.props as Props;

const defaultContent = buildDefaultContent(fromFormat, toFormat);
const activeContent = modifier?.content ?? defaultContent;
const heroTagline = modifier?.heroTagline ?? `Translate ${fromFormat.name} colors into ${toFormat.name} values with professional-grade color science and live previews.`;

const title = modifier
  ? `${toFormat.name} Converter ${modifier.titleSuffix} - Convert from ${fromFormat.name}`
  : `Convert ${fromFormat.name} to ${toFormat.name} - Instant Color Converter`;

const description = modifier
  ? `${modifier.metaDescription} Convert ${fromFormat.name} (${fromFormat.description}) colors to ${toFormat.name} (${toFormat.description}) with Color.js precision and instant previews.`
  : `Convert ${fromFormat.name} (${fromFormat.description}) colors to ${toFormat.name} (${toFormat.description}) format instantly with Color.js accuracy. Works offline in your browser with clipboard-ready results.`;

const keywordPool = new Set<string>([
  `${fromFormat.name} to ${toFormat.name}`,
  `${fromKey} to ${toKey}`,
  'color converter',
  'color space conversion',
  fromFormat.description,
  toFormat.description,
  'online color tool',
  'design colors',
  'color conversion utility',
]);

activeContent.seoKeywords.forEach((keyword) => keywordPool.add(keyword));
if (modifier) {
  keywordPool.add(`${modifier.label.toLowerCase()} color converter`);
  keywordPool.add(modifier.slug.replace(/-/g, ' '));
}

const keywords = Array.from(keywordPool).join(', ');

const example = getExampleConversion(fromKey, toKey);
const defaultInputColor = getDefaultColor(fromKey);
const targetExampleColor = getDefaultColor(toKey);

const canonicalToolSlugMap: Record<SupportedFormat, string> = {
  hex: 'color-converter',
  rgb: 'color-converter',
  hsl: 'color-converter',
  hsv: 'color-converter',
  hwb: 'color-converter',
  lab: 'color-converter',
  lch: 'color-converter',
  oklab: 'color-converter',
  oklch: 'color-converter',
  p3: 'color-converter',
  rec2020: 'color-converter',
  prophoto: 'color-converter',
  a98rgb: 'color-converter',
  xyz: 'color-converter',
  'xyz-d50': 'color-converter',
};

const canonicalToolSlug = canonicalToolSlugMap[toKey];
const ogImagePath = canonicalToolSlug ? `/tools/${canonicalToolSlug}/index.png` : undefined;

const structuredPath = Astro.url.pathname.endsWith('/')
  ? Astro.url.pathname
  : `${Astro.url.pathname}/`;

const structuredDataAudience = modifier?.label ?? 'Designers and developers';
const structuredData = {
  '@context': 'https://schema.org',
  '@type': 'WebApplication',
  name: title,
  description,
  url: `${Astro.site?.origin ?? 'https://formatfuse.com'}${structuredPath}`,
  applicationCategory: 'UtilitiesApplication',
  operatingSystem: 'Any',
  audience: structuredDataAudience,
  offers: {
    '@type': 'Offer',
    price: '0',
    priceCurrency: 'USD',
  },
  featureList: [
    `${fromFormat.name} → ${toFormat.name} converter`,
    ...activeContent.valueProps,
    'Color.js engine for perceptual accuracy',
    'Offline-friendly operation with zero uploads',
  ],
  howTo: {
    '@type': 'HowTo',
    name: `How to convert ${fromFormat.name} to ${toFormat.name}${modifier ? ` for ${modifier.label}` : ''}`,
    step: activeContent.workflowSteps.map((text, index) => ({
      '@type': 'HowToStep',
      position: index + 1,
      text,
      name: `Step ${index + 1}`,
    })),
  },
};

const baseFaqEntities = [
  {
    '@type': 'Question',
    name: `How do I convert ${fromFormat.name} to ${toFormat.name}?`,
    acceptedAnswer: {
      '@type': 'Answer',
      text: `Paste your ${fromFormat.name} color (for example ${example.input}) into the converter. The Color.js engine instantly translates it to ${toFormat.name} (e.g., ${example.output}) with preview swatches and copy-ready output.`,
    },
  },
  {
    '@type': 'Question',
    name: `What is the difference between ${fromFormat.name} and ${toFormat.name}?`,
    acceptedAnswer: {
      '@type': 'Answer',
      text: `${fromFormat.name} (${fromFormat.description}) and ${toFormat.name} (${toFormat.description}) are different color representation systems. Each has its own advantages for specific use cases in design, web development, and color science.`,
    },
  },
];

const faqData = {
  '@type': 'FAQPage',
  mainEntity: [
    ...baseFaqEntities,
    ...activeContent.faq.map((item) => ({
      '@type': 'Question',
      name: item.question,
      acceptedAnswer: {
        '@type': 'Answer',
        text: item.answer,
      },
    })),
  ],
};

const breadcrumbItems = [
  {
    '@type': 'ListItem',
    position: 1,
    name: 'FormatFuse',
    item: 'https://formatfuse.com/',
  },
  {
    '@type': 'ListItem',
    position: 2,
    name: 'Color Converter',
    item: 'https://formatfuse.com/tools/color-converter/',
  },
  {
    '@type': 'ListItem',
    position: 3,
    name: `${fromFormat.name} to ${toFormat.name}`,
    item: `https://formatfuse.com/convert/color/${fromKey}-to-${toKey}/`,
  },
];

if (modifier) {
  breadcrumbItems.push({
    '@type': 'ListItem',
    position: 4,
    name: `${modifier.label} workflow`,
    item: `https://formatfuse.com${structuredPath}`,
  });
}

const breadcrumbData = {
  '@context': 'https://schema.org',
  '@type': 'BreadcrumbList',
  itemListElement: breadcrumbItems,
};

const relatedLinkMap = new Map<string, { href: string; label: string }>();
const addRelatedLink = (href: string, label: string) => {
  if (!relatedLinkMap.has(href)) {
    relatedLinkMap.set(href, { href, label });
  }
};

addRelatedLink(`/convert/color/${toKey}-to-${fromKey}/`, `${toFormat.name} to ${fromFormat.name}`);

const sameFromAlternatives = colorFormatMeta
  .filter((format) => format.key !== fromKey && format.key !== toKey)
  .slice(0, 2);

sameFromAlternatives.forEach((format) => {
  addRelatedLink(`/convert/color/${fromKey}-to-${format.key}/`, `${fromFormat.name} to ${format.name}`);
});

if (modifier) {
  addRelatedLink(`/convert/color/${fromKey}-to-${toKey}/`, `${fromFormat.name} to ${toFormat.name} (all workflows)`);
  const otherModifiers = colorIntentModifiers
    .filter((item) => item.slug !== modifier.slug && isModifierApplicable(item, fromKey, toKey))
    .slice(0, 2);
  otherModifiers.forEach((item) => {
    addRelatedLink(`/convert/color/${fromKey}-to-${toKey}/${item.slug}/`, `${item.label} workflow`);
  });
}

const relatedLinks = Array.from(relatedLinkMap.values()).slice(0, 4);

const formatKeyForBadge = (value: string): string => {
  return value.replace(/-/g, ' ').toUpperCase();
};

const primaryConversionLabel = `${fromFormat.name} → ${toFormat.name}`;
const headerFeatures: HeaderFeature[] = [
  {
    icon: 'swatch-book',
    text: primaryConversionLabel,
    description: `${fromFormat.description} → ${toFormat.description}`,
  },
];

if (modifier) {
  headerFeatures.push({
    icon: 'sparkles',
    text: `${modifier.label} workflow`,
    description: modifier.heroTagline ?? heroTagline,
  });
}

const relatedFeatureIcons = ['arrow-left-right', 'sparkles'] as const;
let relatedIconIndex = 0;

for (const link of relatedLinks) {
  if (headerFeatures.length >= 3) {
    break;
  }

  const iconKey = relatedFeatureIcons[relatedIconIndex] ?? 'sparkles';
  headerFeatures.push({
    icon: iconKey,
    text: link.label,
    description: link.label.toLowerCase().includes('workflow')
      ? 'Explore companion workflows tailored to this conversion.'
      : 'Try another popular color conversion without leaving the tool.',
  });

  relatedIconIndex += 1;
}

while (headerFeatures.length < 3) {
  headerFeatures.push({
    icon: 'sparkles',
    text: '15+ formats supported',
    description: 'Swap between HEX, RGB, LAB, OKLCH, P3, Rec. 2020, and more instantly.',
  });
}

const headerBadge: HeaderBadge = {
  text: `${formatKeyForBadge(fromKey)} → ${formatKeyForBadge(toKey)}`,
  icon: 'swatch-book',
};

const headerOverrides: ResolvedHeaderOverrides = {
  title: `Convert ${fromFormat.name} to ${toFormat.name}`,
  subtitle: heroTagline,
  badge: headerBadge,
  features: headerFeatures,
};

const targetFormatForConverter: TargetFormat = toKey;

const getSourceUsage = (format: SupportedFormat): string => {
  if (['hex', 'rgb', 'hsl', 'hsv', 'hwb'].includes(format)) {
    return 'digital design and interface work';
  }

  if (['lab', 'lch', 'oklab', 'oklch'].includes(format)) {
    return 'perceptual color adjustments and accessibility reviews';
  }

  if (['p3', 'rec2020', 'prophoto', 'a98rgb'].includes(format)) {
    return 'wide-gamut photography, video, and motion workflows';
  }

  if (['xyz', 'xyz-d50'].includes(format)) {
    return 'color-managed production and proofing tasks';
  }

  return 'specialized color science tasks';
};

const getTargetUsage = (format: SupportedFormat): string => {
  if (['hex', 'rgb', 'hsl', 'hsv', 'hwb'].includes(format)) {
    return 'browser-ready color tokens and UI builds';
  }

  if (['lab', 'lch', 'oklab', 'oklch'].includes(format)) {
    return 'perceptually even gradients and accessibility tuning';
  }

  if (['p3', 'rec2020', 'prophoto', 'a98rgb'].includes(format)) {
    return 'wide-gamut storytelling across modern displays';
  }

  if (['xyz', 'xyz-d50'].includes(format)) {
    return 'color-managed documentation and print handoffs';
  }

  return 'specialized applications';
};
---

<Layout
  title={title}
  description={description}
  keywords={keywords}
  ogImage={ogImagePath}
  sourceFormat={fromFormat.name}
  targetFormat={toFormat.name}
>
  <script type="application/ld+json" set:html={JSON.stringify(structuredData)} />
  <script type="application/ld+json" set:html={JSON.stringify(faqData)} />
  <script type="application/ld+json" set:html={JSON.stringify(breadcrumbData)} />

  <main>
    <div class="container mx-auto px-4 py-10 lg:py-14">
      <ColorConverter
        client:load
        initialColor={defaultInputColor}
        targetFormat={targetFormatForConverter}
        autoCopy={true}
        headerOverrides={headerOverrides}
      />

      <section class="mt-16 max-w-4xl mx-auto px-4 sm:px-0">
        <div class="border-t border-border pt-12">
          <h2 class="text-2xl sm:text-3xl font-bold mb-8 text-center">
            Converting <span class="text-primary">{fromFormat.name}</span> to <span class="text-primary">{toFormat.name}</span> Colors
          </h2>

          <div class="space-y-8">
            <div class="text-center text-muted-foreground max-w-3xl mx-auto">
              <p class="text-lg leading-relaxed">{activeContent.summary}</p>
            </div>

            <div class="bg-muted/30 rounded-xl p-6 sm:p-8 mx-auto max-w-4xl">
              <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                <svg class="w-5 h-5 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
                Example Conversion
              </h3>
              <div class="grid sm:grid-cols-2 gap-4">
                <div class="bg-background rounded-lg p-4 border border-border">
                  <p class="text-sm text-muted-foreground mb-2">Input ({fromFormat.name})</p>
                  <code class="text-base font-mono font-semibold break-all">{defaultInputColor}</code>
                </div>
                <div class="bg-background rounded-lg p-4 border border-primary/30">
                  <p class="text-sm text-muted-foreground mb-2">Output ({toFormat.name})</p>
                  <code class="text-base font-mono font-semibold text-primary break-all">{targetExampleColor}</code>
                </div>
              </div>
            </div>

            <div class="grid md:grid-cols-2 gap-6 mt-10">
              <div class="bg-card rounded-xl p-6 border border-border hover:border-primary/30 transition-colors">
                <h3 class="text-lg font-semibold mb-3 flex items-center gap-2">
                  <div class="w-8 h-8 rounded-lg bg-primary/10 flex items-center justify-center">
                    <span class="text-primary font-bold text-sm">A</span>
                  </div>
                  About {fromFormat.name}
                </h3>
                <p class="text-muted-foreground">
                  {fromFormat.description}. This color format is commonly used in {getSourceUsage(fromKey)}.
                </p>
              </div>

              <div class="bg-card rounded-xl p-6 border border-border hover:border-primary/30 transition-colors">
                <h3 class="text-lg font-semibold mb-3 flex items-center gap-2">
                  <div class="w-8 h-8 rounded-lg bg-primary/10 flex items-center justify-center">
                    <span class="text-primary font-bold text-sm">B</span>
                  </div>
                  About {toFormat.name}
                </h3>
                <p class="text-muted-foreground">
                  {toFormat.description}. Converting to this format is useful for {getTargetUsage(toKey)}.
                </p>
              </div>
            </div>

            <div class="mt-10">
              <h3 class="text-lg font-semibold mb-4 text-center">Common Use Cases</h3>
              <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 max-w-3xl mx-auto">
                {activeContent.useCases.slice(0, 4).map((item) => (
                  <div class="flex items-start gap-3 p-3 rounded-lg hover:bg-muted/30 transition-colors">
                    <svg class="w-5 h-5 text-primary mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span class="text-sm text-muted-foreground">{item}</span>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </main>
</Layout>
