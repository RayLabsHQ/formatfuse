---
import Layout from "../../layouts/Layout.astro";
import PdfSplit from "../../components/converters/PdfSplit.tsx";
import PdfMerge from "../../components/converters/PdfMerge.tsx";
import PdfRotate from "../../components/converters/PdfRotate.tsx";
import JpgToPdf from "../../components/converters/JpgToPdf.tsx";
import PdfToJpg from "../../components/converters/PdfToJpg.tsx";
import MarkdownToPdf from "../../components/converters/MarkdownToPdf.tsx";
import "../../styles/global.css";
import {
  alternateRoutes,
  pdfToolsSeo,
  imageToPdfFormats,
  pdfToImageFormats,
} from "../../data/pdf-seo";

export function getStaticPaths() {
  const toolMap = [
    {
      slug: "jpg-to-pdf",
      component: "JpgToPdf",
      toolType: "pdf",
      sourceFormat: "jpg",
      targetFormat: "pdf",
    },
    {
      slug: "pdf-merge",
      component: "PdfMerge",
      toolType: "pdf",
    },
    {
      slug: "pdf-split",
      component: "PdfSplit",
      toolType: "pdf",
    },
    {
      slug: "pdf-rotate",
      component: "PdfRotate",
      toolType: "pdf",
    },
    {
      slug: "pdf-to-jpg",
      component: "PdfToJpg",
      toolType: "pdf",
      sourceFormat: "pdf",
      targetFormat: "jpg",
    },
    {
      slug: "markdown-to-pdf",
      component: "MarkdownToPdf",
      toolType: "text",
      sourceFormat: "markdown",
      targetFormat: "pdf",
    },
  ];

  const basePaths = toolMap.map((tool) => {
    const seo = pdfToolsSeo[tool.slug] || {
      title: tool.slug,
      description: "",
      keywords: [],
    };
    return {
      params: { tool: tool.slug },
      props: {
        title: seo.title,
        component: tool.component,
        description: seo.description,
        toolType: tool.toolType,
        sourceFormat: tool.sourceFormat,
        targetFormat: tool.targetFormat,
        isAlternate: false,
        canonicalSlug: tool.slug,
      },
    };
  });

  const toolLookup = new Map(toolMap.map((t) => [t.slug, t]));

  const altPaths = alternateRoutes
    .filter(({ canonical, alt }) => canonical !== alt && toolLookup.has(canonical))
    .filter(({ alt }) => {
      const reserved = new Set<string>([
        ...imageToPdfFormats.map(({ format }) => `${format}-to-pdf`),
        ...pdfToImageFormats.map(({ format }) => `pdf-to-${format}`),
      ]);
      return !reserved.has(alt);
    })
    .map(({ alt, canonical }) => {
      const tool = toolLookup.get(canonical)!;
      const seo = pdfToolsSeo[canonical] || {
        title: canonical,
        description: "",
        keywords: [],
      };
      return {
        params: { tool: alt },
        props: {
          title: seo.title,
          component: tool.component,
          description: seo.description,
          toolType: tool.toolType,
          sourceFormat: tool.sourceFormat,
          targetFormat: tool.targetFormat,
          isAlternate: true,
          canonicalSlug: canonical,
        },
      };
    });

  return [...basePaths, ...altPaths];
}

const { tool } = Astro.params;
const {
  title,
  component,
  description,
  toolType,
  sourceFormat,
  targetFormat,
  isAlternate,
  canonicalSlug,
} = Astro.props;
---

<Layout
  title={title}
  description={description}
  toolType={toolType}
  sourceFormat={sourceFormat}
  targetFormat={targetFormat}
>
  {isAlternate && (
    <link
      slot="head"
      rel="canonical"
      href={new URL(`/convert/${canonicalSlug}`, Astro.site)}
    />
  )}
  <main class={component === "MarkdownToPdf" ? "flex flex-col h-[calc(100vh-4rem)] md:h-auto min-h-0" : ""}>
    {component === "PdfSplit" && <PdfSplit client:load />}
    {component === "PdfMerge" && <PdfMerge client:load />}
    {component === "PdfRotate" && <PdfRotate client:load />}
    {component === "JpgToPdf" && <JpgToPdf client:load />}
    {component === "PdfToJpg" && <PdfToJpg client:load />}
    {component === "MarkdownToPdf" && <MarkdownToPdf client:load />}
    {/* Add more component conditions here */}
  </main>
</Layout>
